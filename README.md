# Practical API Design

- [Practical API Design: Confessions of a Java Framework Architect](https://www.apress.com/gp/book/9781430209737)
- [자바 API 디자인](https://wikibook.co.kr/practical-api-design/)

1. 이론과 정당성
1. 실제 설계
1. 일상 생활

---

## 들어가기

- 프레임워크, 공유 라이브러리 설계
- 하위 호환성을 보장하는 설계

API는 별과 같아서 한번 도입되고 나면 영원히 그 자리에 존재한다.

**왜 API를 만드는 것인가?**  
**API란 무엇인가?**

**API 설계를 배워야 하는 이유:**  
서로 이해한 바를 공유하게 되어  
의사소통이 단순해지고  
의사 결정을 따로 설명할 필요가 없어진다.

팀원 간의 협동이 향상되고,  
결과적으로 **좋은 품질의 소프트웨어**로 이어진다.

---

## 1. 이론과 정당성

**API 설계는 공학적인 체계가 필요하다.**  
API를 개발할 때 저마다 창의성을 드러낸다면 일관성이 떨어진다.  
API 아키텍트는 팀원 사이에서 조율하기 힘들어진다.  
팀원들과 비전을 공유해야 하고,  
비전을 표현하는 어휘, 비전 달성을 할 수 있는 방법론도 필요하다.

API를 설계할 때는 개인적인 선호뿐 아니라 문화적인 차이도 고려해야 한다.

### Chapter 1. 현대 소프트웨어 구축의 예술

선택적 무지: selective cluelessness

소프트웨어 개발에서 목표는 안정적으로 출시하는 것이다.  
시스템의 동작과정을 전부 이해하지 않아도 된다.  
실용적으로 기존 라이브러리, 프레임워크를 조합하여 시스템을 완성한다.  

마찬가지로 API는 복잡한 것을 감추는 역할을 한다.

### Chapter 2. API를 만드는 이유

API는 컴포넌트의 기능과 내부 구현을 추상화한 것이다.  
때로는 추상화 너머 실제 구현이 누출될 수 있다.  
우리는 이때 컴포넌트의 내부를 알면 도움이 된다.

애플리케이션 개발에서 첫 단계는 무지한 상태에서 라이브러리를 사용하는 것이다.  
따라서 컴포넌트를 재사용하기 위해서는 API 설계가 훌륭해야 한다.

컴포넌트를 이해하지 못해도 수 많은 컴포넌트를 조립할 수 있는 능력이 필요하다.

1. 컴포넌트는 적절한 이름을 가진다.
1. 컴포넌트는 필요한 환경 정보를 전달해야 한다.
1. 컴포넌트 의존성은 자동으로 처리되어야 한다.
1. 컴포넌트의 하위 호환성은 유지되어야 한다.

의사소통 채널:
1. API 자체
1. API의 문서

모듈화된 애플리케이션에게 필요한 API:
1. 명확하다.
1. 이해하기 쉽다.
1. 스스로 설명한다.
1. 문서화가 잘 되어 있다.

신뢰할 수 있는 API:
1. 일어날 만한 실수를 미리 방지한다.
1. 진화할 준비가 갖추어져 있다.

각 컴포넌트는 독립적으로 진화하기 때문에 안정적인 계약이 필요하다.

호환성 단절은 신뢰를 저버리는 것이다.

첫 번째 버전은 늘 쉽다.

### Chapter 3. 훌륭한 API를 결정하는 요소

관점: 다른 사람들이 무슨 일을 했는지 알아보는 시간 낭비를 하지 않아야 한다.

- 메서드와 필드 시그너처
- 파일과 파일의 내용
- 환경변수와 명령줄 옵션
- 프로토콜: 적절한 핸드셰이크 필요
- 동작방식: 컴포넌트 추상화 누출과 같은 사용자의 이해 필요
- I18N 지원과 L10N 메시지
- 넓은 의미의 API: DB, XML 스키마, WDDL, REST, IDL

API 품질 검사 방법:
- 이해도
- 일관성
- 발견 가능성: API 적용을 시작할 수 있는 진입점 표시
- 단순한 작업은 쉬워야 한다: 사용자 그룹에 따른 API 설계
- 투자 보전: API 사용자들이 투자한 시간, 연구, 노력, 돈을 보전해야 한다. API를 사용하는 사람들을 행복하게 만들어야 한다.

애플리케이션은 가장 부하가 심한 조건에서 테스트하는 것이 좋다.  
WWW는 최고의 오픈소스 프로젝트이다.

### Chapter 4. 시시각각 변하는 표적

훌륭한 API는 시간이 흐른 뒤에도 살아남는다.

첫 번째 버전은 결코 완벽하지 않다.

모든 API 제작자는 진화 계쇡을 마련해 둬야 한다.  
향후 릴리스에서 API에 어떤 일이 발생할지  
전략적인 차원에서 알고 있어야 한다.

#### 하위 호환성

- 소스 호환성: 컴파일 할 수 있는가? 어렵다.
- 바이너리 호환성: 이전 버전으로 컴파일된 프로그램이 새 API와 링크될 수 있는가?
  1. 한 번 컴파일하여 여러 버전으로 사용할 수 있다.
  1. 이전 버전 빌드 사용자가 새 라이브러리로 마이그레이션 할 수 있다.
  - 자바 특성: 자바 소스 코드와 바이트 코드는 다르다
    - jasm, BCEL, classfile 등으로 분석, 변경 가능
- 기능적 호환성: 동일한 결과를 보이는가?
  - 아메바 효과: 명세와 실제 구현이 차이난다.

API 설계자는 잘못된 동작 방식, 사용 방식까지 책임을 져야 한다.

#### 유스 케이스 지향

API 명세와 실제 구현 간의 차이를 작게 만들어야 한다.

- 유스 케이스: 어떻게 이렇게 하는가?
  - API에서 의도하는 사용법을 설명한 것.
  - 잠재 사용자가 겪을 문제를 보여준다.
- 시나리오: 유스 케이스의 답변
  - 실제 단계를 설명한 것.
- (자바독)

명세를 작성하여 차이를 측정해야 유지보수를 할 수 있다.

#### API 검토

규칙:
1. 유스 케이스 기반 API 설계
1. 일관성 있는 API 설계
1. 단순하고 깔끔한 API 설계
1. 더 적은 것이 더 많다
1. 진화 대비

#### API의 생명 주기

API를 만드는 과정은 의사소통에 관한 것이다.

#### 점진적 향상

API의 변화가 필요할 때 두 가지 대응 방법:

1. 빅뱅 방식: 새로운 버전을 만든다.
   - 장점: 비호환성 문제를 방지한다.
   - 단점: 
     - 클라이언트는 번경하기 쉽지 않다.
     - 변경 후에도 빅뱅 방식이 또 필요할 수 있다.
   - 설계와 개발, 테스트 방벚에 문제가 있을 것이다.
1. 점진적 진화 방식
   - 장점:
     - 클라이언트 피해가 적다.
     - 클라이언트 수정 없이 버그 수정과 성능 향상 및 룩앤필 개선이 가능하다.
   - 단점:
     - 하위 호환성에 잠재적인 위험성이 존재한다.
     - 버그 하나가 두 개로 늘어날 수 있다.

중요한 것은 컴포넌트의 신뢰성과  
해당 컴포넌트를 설계한 사람의 책임감이다.

---

## 2. 실제 설계

API는 의사소통에 관한 것이다.  
같은 언어를 공유하고,  
공통적으로 이해할 수 있는 구성요소를 사용하면  
더 성공적으로 의사소통을 할 수 있다.

디자인 패턴:
- 디자인 패턴은 출발점으로 좋다.
- API 설계자 사이에서 기본적인 의사소통 어휘로 사용하기에 알맞다.
- 디자인 패턴은 "소프트웨어 설계 문제에 대한 반복되는 해결책"이다.

**API 설계자들은 진심으로 디자인 패턴을 알아둘 필요가 있다.**

API 디자인 패턴을 만든다.
- 패턴 이름
- 문제 설명
- 해결책
- **진화 계획**

### Chapter 5. 필요 이상으로 노출하지 마라

더 적게 노출할 수록 더 좋다.  
겉으로 노출되는 것이 많을수록 구현의 내부 구조를 변경할 때 누릴 수 있는 유연성은 줄어든다.  
다양한 유스케이스가 있는 것으로 API를 만든다.  
실력이 부족할수록 API가 장황해진다.  
API를 통해 노출되는 모든 메서드와 클래스는 잘못 사용될 것이다.  
API를 처음으로 릴리스하기에 앞서 제거할 수 있는 것은 모조리 제거하라.  
API를 공표함으로써 나중에 훨씬 더 많은 일을 할 것이라고 약속하는 것이다.  
최종 사용자에게 우리가 발걸음을 옮기고 있다는 사실을 감추는 것이다.
핫스팟 JVM에서는 정적으로 컴파일된 코드보다 인터프리트(동적으로 컴파일)된 코드가 빠를 수 있다.  
자바에서는 성능을 위하 API 캡슐화를 희생할 필요가 없다.

1. 필드를 감추고 메서드를 사용한다.
   - 메소드는 필드 읽기/쓰기와 함께 추가적인 작업이 가능하다.
   - 한 클래스의 메서드는 상위 클래스로 옮길 수 있다.
1. 생성자보다 팩터리가 낫다.
   - API를 진화시키기가 수월하다.
   - 반환하는 클래스 타입이 유연하다.
   - 인스턴스를 캐싱할 수 있다.
   - 동기화를 할 수 있다.
1. 모든 것을 final로 만들어라.
   - 클래스, 생성자, 메서드
   - final이나 private
1. 어울리지 않는 곳에 설정자를 넣지 마라.
1. 프렌드 코드에서만 접근하는 것을 허용하라.
   - package private
   - 런타임 컨테이너를 이용한 코드 보안
   - 클래스 로딩 단계에서 패키지 접근을 막을 수 있다.
1. 객체를 만든 이에게 더 많은 권한을 부여하라.
1. 깊은 계층 구조를 노출하지 마라.
   - 서브클래식에 엄격해진다.

### Chapter 6. 구현이 아닌 인터페이스를 대상으로 코드를 작성하라


