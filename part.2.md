# 2. 실제 설계

API는 의사소통에 관한 것이다.  
같은 언어를 공유하고,  
공통적으로 이해할 수 있는 구성요소를 사용하면  
더 성공적으로 의사소통을 할 수 있다.

디자인 패턴:
- 디자인 패턴은 출발점으로 좋다.
- API 설계자 사이에서 기본적인 의사소통 어휘로 사용하기에 알맞다.
- 디자인 패턴은 "소프트웨어 설계 문제에 대한 반복되는 해결책"이다.

**API 설계자들은 진심으로 디자인 패턴을 알아둘 필요가 있다.**

API 디자인 패턴을 만든다.
- 패턴 이름
- 문제 설명
- 해결책
- **진화 계획**

## Chapter 5. 필요 이상으로 노출하지 마라

- 더 적게 노출할 수록 더 좋다.  
- 겉으로 노출되는 것이 많을수록 구현의 내부 구조를 변경할 때 누릴 수 있는 유연성은 줄어든다.  
- 다양한 유스케이스가 있는 것으로 API를 만든다.  
- 실력이 부족할수록 API가 장황해진다.  
- API를 통해 노출되는 모든 메서드와 클래스는 잘못 사용될 것이다.  
- API를 처음으로 릴리스하기에 앞서 제거할 수 있는 것은 모조리 제거하라.  
- API를 공표함으로써 나중에 훨씬 더 많은 일을 할 것이라고 약속하는 것이다.  
- 최종 사용자에게 우리가 발걸음을 옮기고 있다는 사실을 감추는 것이다.
- 핫스팟 JVM에서는 정적으로 컴파일된 코드보다 인터프리트(동적으로 컴파일)된 코드가 빠를 수 있다.  
- 자바에서는 성능을 위하 API 캡슐화를 희생할 필요가 없다.

1. 필드를 감추고 메서드를 사용한다.
   - 메소드는 필드 읽기/쓰기와 함께 추가적인 작업이 가능하다.
   - 한 클래스의 메서드는 상위 클래스로 옮길 수 있다.
1. 생성자보다 팩터리가 낫다.
   - API를 진화시키기가 수월하다.
   - 반환하는 클래스 타입이 유연하다.
   - 인스턴스를 캐싱할 수 있다.
   - 동기화를 할 수 있다.
1. 모든 것을 final로 만들어라.
   - 클래스, 생성자, 메서드
   - final이나 private
1. 어울리지 않는 곳에 설정자를 넣지 마라.
1. 프렌드 코드에서만 접근하는 것을 허용하라.
   - package private
   - 런타임 컨테이너를 이용한 코드 보안
   - 클래스 로딩 단계에서 패키지 접근을 막을 수 있다.
1. 객체를 만든 이에게 더 많은 권한을 부여하라.
1. 깊은 계층 구조를 노출하지 마라.
   - 서브클래식에 엄격해진다.

## Chapter 6. 구현이 아닌 인터페이스를 대상으로 코드를 작성하라

단순히 애플리케이션의 일부가 API라고 주장하는 것만으로는 부족하다.  
API에 해당하는 부분들은 강조해서 보여줄 필요가 있다.

인터페이스를 구현과 분리해야 한다.

## Chapter 7. 모듈화 아키텍처를 사용하라

처음부터 모듈성을 염두에 두고 프로젝트를 시작하는 것이 중요하다.

개념:

- 의존성 주입, 컴포넌트 주입
- `System.getProperty`, XML 설정 파일, Annotation
- Java Extension Mechanism
- Lookup, Service Locator
- 순환 의존성 해결, Facade Pattern

## Chapter 8. 클라이언트와 제공자를 위한 API를 분리하라

Service Provider Interface: 서비스 제공자 인터페이스

- 클라이언트를 위한 API: 추가 O, 제거 X
- 구현자를 위한 API: 추가 X, 제거 O

가장 큰 실수는 한 클래스 내에서 API와 SPI를 한데 섞는 것이다.

항상 API를 SPI와 분리하라.  
API 패키지에 들어 있는 클래스는 자족적이어야 한다.  
SPI 패키지에 들어 있는 클래스를 참조해서는 안 된다.

1. 진화
1. 가독성: 지역성을 제공하라. 가장 근접한 방식으로 구성하라.

## Chapter 9. 테스트 용이성을 염두에 둬라

테스트는 효과적이다.

- 계획 능력을 향상시킨다.
- "기능 동결" 효과를 제거한다: feature freeze

테스트하기 쉬운 API를 작성하라.

일반 API와 함께 테스트 API도 제공한다.  
테스트를 작성하는 용도로만 사용한다.  
package private 메서드를 이용할 수 있다.

1. 가장 중요한 것은 **적기 출시**다.
   - API와 프레임워크를 매력적으로 만든다.
1. **적절한 생성 도구**는 지저분하고 복잡한 기술도 빛나는 다이아몬드로 보여줄 수 있다.
	 - 대화식 예제가 필요하다.
   - 개발자들이 가장 하고 싶어하는 일 = 즉 라이브러리를 이용해 애플리케이션을 만드는 일
   - 즉시 준비돼 있는 문서를 만들어야 한다.

모듈화 라이브러리 API 구현체의 일관성 강제 방법:

1. 10장 "API의 일관성 강제하기"
1. 테스트 호환성 도구(TCL; test Compatilbility kit)
   - 예쌍되는 기능적 동작 방식과의 일관성을 검증하는 데 사용할 수 있는 테스트 집합 제공

소스코드를 연구해야 한다는 것은 API가 엉망으로 만들어진 것이다.

TCK를 사용하는 사람들은 가장 귀중한 API 사용자다.

## Chapter 10. 다른 API와 협동하기

다른 API와 쉽게 공존하는 방식으로 설계해야 한다.

### 다른 API를 사용하는 것을 조심하라

재전달 re-export:
- 다른 라이브러리의 API를 노출하는 것.
- 메서드가 다른 라이브러리에서 정의한 타입을 반환하거나 인자로 받아들일 때 발생
- 하위 호환성 문제 발생 가능

호환되지 않은 변경의 이행성 transitivity:
- 다른 라이브러리가 호환되지 않는 변경을 한 경우 모든 라이브러리들에게 영향을 미침

예방 방법:
1. 비호환성 유지: 기반 라이브러리의 모든 비호환성과 함께 또 하나의 비호환성이 도입됨
1. 비호환성 거부: 어려움. 직접 라이브러리 개발에 참여해야 함. 
1. wrapper 사용: 라이브러리 사용을 내부적으로 숨긴다.
	- 호환되지 않는 변경사항의 이행성이 제거된다.
	- 사용자가 익혀야 할 API 양이 늘어난다.

### 추상화 누출

자신의 API를 노출할 때도 사용자에게 많은 권한이 넘어갈 수 있다.  

예: java.io.File

더 적게 노출할수록 API를 재사용하기 더 쉬워진다.

### API의 일관성 강제하기

1. 정책 policy 정의: 아무것도 안 하는 것보다는 낫다.
1. TCK 작성: 모든 구현체가 일관성을 지킬 것이라고 보장할 수는 없다.
1. 일관성 강제: 제약조건 언어 사용, 관점 지향 프로그래밍 사용 등

매서드를 재정의하지 못하도록 클래스를 final로 만들고 클래스 본문에서 일관성을 검사한다.

### 위임과 합성

객체 지향에서 상속 대신 합성을 사용한다.

1. final 클래스
1. 인터페이스
1. 클래스, 추상클래스: public final, protected abstract, protected final

### API를 잘못 사용하지 않게 하라

예: 타입 체계와 런타임의 비일관성

### 자바빈 리스너 패턴을 남용하지 마라

콜백 패턴을 사용하면 좋다.

## Chapter 11. API의 런타임 측면

API가 애플리케이션에 링크가 된 다음부터 진짜 모험이 시작된다.

- 기능적 호환성의 의미를 알고 이해해야 한다.
- 사용자는 무엇이 옳고 그른지 신경 쓰지 않는다.
- 런타임 차이를 방지해야 한다.
- 책임감을 지녀야 한다.
- 선택적 무지와 신뢰할 수 있는 코드를 만드는 것 사이의 관계를 안다.

동작 방식 변경의 사회학적인 의미: 소프트웨어 사용자의 신뢰를 지켜야 한다.

자동화된 테스트로 신뢰성을 높일 수 있다.

### 동기화와 교착상태

- 스레드 모델을 적절히 문서화한다.
- 라이브러리 제작자가 가장 등한시하는 부분이다.
- 스레드에 안전한 API
- 외부 코드를 호출하는 동안 잠금을 점유하지 마라.
- 서브클래싱과 리스너는 교착상태 발생 위험이 있다.
- 계층구조식 순서에서 역으로 호출하게 되면 교착상태가 발생한다.
- 전용 디스패치 스레드 내에서 리스너를 비동기적으로 호출해야 한다.
- 메시지 기반 프로그램이라면 대기가 사라진다.
- 그 외 프로그램이나 라이브러리는 제한 시간이 있는 대기만 허용한다.
- 테스트 작성을 통해 알려진 교착상태를 모두 제거한다.
- 순수한 회귀 테스트 regression test: 버그가 보고 됐을 때 작성한다.
- 로깅을 이용해 스레드 실행 흐름을 제어할 수 있다.

교착상태의 조건:
- Mutual Exclusion: 상호배제
- Hold and Wait: 점유대기
- No preemption: 비선점형 스케줄링
- Circular Wait: 순환 참조

### 재진입성 호출 대비

reentrant 접근을 받아들이거나 예방해야 한다.

### 메모리 관리

런타임의 특징과 구조, 상호 조직화, 메모리 상의 각 객체 간의 참조에 대해 주의한다.

- 메모리 모델을 문서화해야 한다.
- 테스트를 작성하여 메모리 모델의 동작 방식을 구체화할 수 있다.
- API의 기능적 명세의 일부가 된다.
- 능동적인 명세가 된다.

## Chapter 12. 선언형 프로그래밍

런타임을 완전히 제거한다.

- 불변 객체 생성
- 불변적인 동작 방식
- 문서의 호환성
